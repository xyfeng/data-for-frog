<!-- http://paperjs.org/examples/hit-testing/ -->
<!-- http://paperjs.org/reference/path/#path-regularpolygon-object -->
<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Topics</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400' rel='stylesheet' type='text/css'>
  <style>
    body{
      margin:0;
      padding:0;
      font:12px/17px Arial, sans-serif;
      background:#fff;
    }
    #viewport {
      width:100%;
      height:100%;
    }
  </style>
</head>

<body>
  <canvas id="viewport" resize></canvas>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>

  <script src="lib/arbor.js"></script>
  <script src="lib/arbor-tween.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.18/paper-full.min.js"></script>

  <!-- drawing
  <script src="lib/arbor-graphics.js"></script>
  <script src="lib/arbor-renderer.js"></script>
  <script src="data/indicators.js"></script>
  -->
  <script src="data/test.js"></script>

  <script>
    paper.install(window);

    $(function() {
      paper.setup('viewport');
      var particleSystem = null;
      var edgeGroup = new Group();
      var nodeGroup = new Group();
      var myRenderer = {
        init:  function(system){
          console.log(system);
          particleSystem = system;
          particleSystem.screenSize(window.innerWidth, window.innerHeight);
          particleSystem.screenPadding(100);

          particleSystem.eachEdge(function(edge, pt1, pt2){
            var edgeGraphic = createEdge(pt1.x, pt1.y, pt2.x, pt2.y);
            edge.data.graphic = edgeGraphic;
          });

          particleSystem.eachNode(function(node, pt){
            // console.log(node);
            var label = node.data.label||""
            var nodeGraphic = createNode(label, pt.x, pt.y);
            node.data.graphic = nodeGraphic;
          });
          view.draw();
        },
        redraw:function(){
          particleSystem.eachEdge(function(edge, pt1, pt2){
            var line = edge.data.graphic;
            var point = line.segments[0].point;
            point.x = pt1.x;
            point.y = pt1.y;
            point = line.segments[1].point;
            point.x = pt2.x;
            point.y = pt2.y;
          });
          particleSystem.eachNode(function(node, pt){
            node.data.graphic.position = new Point(pt.x, pt.y);
          });
          view.draw();
        }
      }

      var sys = arbor.ParticleSystem(2000, 900, 1, true, 30, 0.015, 0.6);
      sys.renderer = myRenderer;
      sys.graft(data);

      var createNode = function (name, x, y){
        var textLabel = new PointText({
          point: [x, y + 4],
          content: name,
          fillColor: 'black',
          fontFamily: 'Source Sans Pro',
          fontWeight: 200,
          fontSize: 8,
          justification: 'center'
        });
        var nodeShape = new Path.RegularPolygon({
          center: [x, y],
          sides: 6,
          radius: 30,
          strokeColor: 'red',
          fillColor: '#ffffff'
        });
        var one = new Group(nodeShape, textLabel);
        nodeGroup.addChild(one);
        return one;
      }

      var createEdge = function (x1, y1, x2, y2) {
        var line = new Path.Line({
          from: [x1, y1],
          to: [x2, y2],
          strokeColor: 'black',
          strokeWidth: 0.2
        });
        edgeGroup.addChild(line);
        return line;
      }

      var removeNode = function(node) {
        node.data.graphic.remove();
        var array = particleSystem.getEdgesTo(node);
        for (var i=0; i<array.length; i++){
          array[i].data.graphic.remove();
        }
        particleSystem.pruneNode(node);
      }

      var removeNodeChildren = function(node) {
        var array = particleSystem.getEdgesFrom(node);
        if( array.length ){
          for (var i=0; i<array.length; i++){
            removeNodeChildren(array[i].target);
            removeNode(array[i].target);
          }
        }
      }

      var mouseFlag = 0;
      var clicked, dragged, hovered;

      $('#viewport').mousedown(function(e){
        if(particleSystem === null)
          return;
        clicked = null;
        dragged = null;
        point = arbor.Point(e.pageX, e.pageY);
        var nearest = particleSystem.nearest(point);
        if (nearest.node == null)
          return;
        if (nearest.distance < 30){
          clicked = nearest.node;
          clicked.fixed = true;
          mouseFlag = 1;
        }
        return false;
      });

      $('#viewport').mousemove(function(e){
        if(particleSystem === null)
          return;
        if (mouseFlag === 0){
          // console.log('hover');
          point = arbor.Point(e.pageX, e.pageY);
          var nearest = particleSystem.nearest(point);
          if (nearest == null || nearest.node == null)
            return;
          if (nearest.distance < 30){
            hovered = nearest.node;
            // console.log(hovered.data.label);
          }
        }
        else if (mouseFlag === 1){
          // console.log('drag');
          dragged = clicked;
          var s = arbor.Point(e.pageX, e.pageY);
          var p = particleSystem.fromScreen(s);
          dragged.p = p;
        }
        return false;
      });

      $('#viewport').mouseup(function(e){
        if(particleSystem === null)
          return;
        if(mouseFlag === 1){
          if(dragged !== null){
            // console.log('drag off');
            dragged.fixed = false;
            dragged.tempMass = 50;
            dragged = null;
          }
          else{
            // console.log('click');
            var array = particleSystem.getEdgesFrom(clicked);
            if (array.length > 0){
              // if (particleSystem.getEdgesTo(clicked).length){
                removeNodeChildren(clicked);
              // }
            }
            else{
              //add random nodes
              var count = Math.floor(Math.random() * 6) + 1;
              var nodePos = particleSystem.toScreen(clicked.p);
              for (var i=0; i<count; i++){
                //create node
                var node = particleSystem.addNode(clicked.name + '_' + i);
                node.tempMass = .001
                node.p = particleSystem.fromScreen(nodePos);
                var nodeGraphic = createNode('item', node.p.x, node.p.y);
                node.data.graphic = nodeGraphic;
                //create edge
                var edge = particleSystem.addEdge(clicked, node);
                var edgeGraphic = createEdge(clicked.p.x, clicked.p.y, node.p.x, node.p.y);
                edge.data.graphic = edgeGraphic;
              }
            }
            clicked.fixed = false;
            clicked = null;
          }
        }
        mouseFlag = 0;
        return false;
      });

    });
  </script>

</body>

</html>
